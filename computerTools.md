# Computer Tools for Electrical Engineers

> This file is contains the course notes after the midterm. --_Gökhan Koçmarlı_
>
> Course: EE2021
> Lecturer: Dr. Onur Cihan
> Credit: 5

* Each element of a **cell array** can hold any type of MATLAB data, and different elements within the same array can hold different types of data.
	* Cell arrays use braces {} for selecting and displaying the contents of cells. It because when you type () instead of {}, you ask the content of that particular place. Since cell arrays contains like the pointers, the content of that place is a pointer to the real content. We use {} to reach that real content. Thing it is like, when you use {}, you say the MATLAB: "Go to the () and get me it's content!"
	* You can create a cell array with assignments but you should use `cell()` function for preallocation purposes.
	* Strings in cell arrays don't need to be in a same size, so that you can use this approach.
	
* **Structures** are a special type of array with named sub components.
	
	* You can create a array with containing structures.
	* You can create structures with assignments but you should use `struct()` function for pre-allocation purposes. For example, `student(1000) = struct('Name', [], 'Addr', [], 'City', [])` will create a struct array which contains 1000 different students.
	* If a new field name is defined for any element in a structure array, the field is automatically added to all of the elements in the array.
	* To extract the values from a given field across multiple array elements, simply place the structure and field name inside a set of brackets. For example, `[student.zip]`.
	* You can use dynamic field names in order to access some data with field names which can be changed during program execution. Static field name is `student(1).name` and dynamic field name is `student(1).['name']`.
	* You can use nested structure arrays.
	
* MATLAB has a very flexible method to read and write files, whether they are on a disk, memory stick, or some other device attached to the computer. This mechanism is known as the **file id** (sometimes known as fid). The file id is a number assigned to a file when it is opened and used for all reading, writing, and control operations on that file. The file id is a positive integer. fid 1 is _stdout_ and fid 2 is _stderr_. 

* **Handle graphics** is the name of a set of low-level graphics functions that control the characteristics of graphics objects generated by MATLAB. Each component has a list of properties that define what it looks like and how it behaves. GUI creation with GUIDE uses this methods.

  * Example `set()` and `get()` usage in GUI programming. In here, _hObject_ is the callback object given you to access that component's properties. You can use _handles_ for this purpose, too; but, it contains all the components that figure have. You have to reach that particular component with structural accessing methods (like, handles.pushbutton1). _eventdata_ isn't working now. It is preserved for future versions of MATLAB.

    ```matlab
    function pushbutton1_Callback(hObject, eventdata, handles)
    	user_data = get(handles.pushbutton1, 'Value')
    	set(handles.pushbutton1, 'propertyName', 'Value')
    ```

  * You shouldn't forget to convert values type of string to the doubles. Text-boxes and etc., gets inputs as strings.

  * If you want to exchange variables within callback functions, you should assign that value to a new sub field of the `handles` structure and then save the `handles` structure.

    ```matlab
    function callbackFuncA(hObject, eventData, handles)
    	% (...)
    	variableName = 15; % The datum which we want to exchange.
    	handles.fieldNameToStore = variableName; % Assigning
    	guidata(hObject, handles); % Saving the handles structure
    	% (...)
    
    function callbackFuncB(hObject, eventData, handles)
    	% (...)
    	variableNameToGet = handles.fieldNameToStore;
    	% (...)
    ```

  * For creating an executable file, check the _Apps_ tab and find _Application Compiler_.
  
  * In order to get files from the GUI, you can use `uigetfile()` function.

## Cheat-sheet

### Complex Numbers Related Functions

* `real()`	converts the real part of the complex number into a double and throw away the complex part.
* `imag()`	converts the complex part of the complex number into a real number and throw the real part.
* `abs()`	calculates the absolute of the complex number with $abs = \sqrt{real^2 + imag^2}$
* `angle()`	calculates the angle of polar version of complex number. (= `atan2(imag(c), real(c))`). Answer is in a range of $-\pi \le \theta \le \pi$.
* `isreal()`	checks if the parameter is only a real number.
* `conj()`	gives the complex conjugate of the number. Complex conjugate means that the opposite sign of complex part.

> When we use plot() function to plot something with complex numbers, it'll chose x-axis as real numbers and y-axis as imaginary numbers. If you don't want this approach, you can use `real(c)` and `imag(c)` functions to draw two separate lines in one figure while `holding on`. Note that, you can use `polar()` command for plotting in a circular area.

<hr>

### Strings Related Functions

* `ischar()`	can be used to check if the variable is character or character array.
* `double()`	to change chars to double with ASCII codes.
* `char()`	to change a type to char with ASCII codes.
* `deblank()`	to remove/trim the spaces (blank characters) from the char array (in tail).
* `strtrim()`	to remove/trim the spaces in both tail and leading.
* `strcat()`	concats the given parameter strings horizontally.
* `strvcat()`	concats the given parameter strings vertically. You can do this with char() and MATLAB does not recommend to use strvcat().
* `strcmp()`	comparing strings if they are identical.
* `stricmp()`	comparing strings if they are identical but not case-sensitive.
* `strncmp()`	comparing strings' first n if they are identical.
* `strncmpi()`	comparing strings' first n if they are identical but not case-sensitive.
> The operators like `==`, `>=`, `<` will control every char separately and give an output of logical array but if the both character arrays length are the same.

* `isletter()`	 determines whether a character is a letter.
* `isspace()`	determiner whether a character is a white space.
* `isstrprop()`	general way to check if the characters are in the category (such as digits, lowercase, alphabetic).
* `findstr()`	returns the starting point of all occurrences of the sub-string in the string.
*  `strmatch()`	looks at the beginning of characters of the rows of a two-dimensional character array and returns a list of those rows that start with the specified character sequence.
* `strrep()`	searches and replaces.
* `strtok()` 	returns the characters before the first occurrence of a delimiting character in an input string. MATLAB recommends to use `split()` instead.
* `upper()`	converts the string uppercase.
* `lower()`	converts the string lowercase.
* `int2str()`	integer into string converter
* `num2str()`	double into string converter
* `eval()`	to evaluate the code inside the string.
* `str2double()`	string into double converter
* `sscanf()`	string into number according to a format-conversion character.

<hr>

### Plotting Functions
* `bar(x, y)`	Creates vertical bar plot. _x_ are the labels for x-axis and _y_ are the height for every _x_ component.
* `barh(x, y)`	Creates horizontal bar plot. _x_ are the labels for y-axis and _y_ are the height for every _x_ component.
* `compass(x, y)`	Creates a polar plot with an arrow drawn from the origin to the location of each (x, y) point. Note that it uses Cartesian coordinates.
* `pie(x)`	Creates pie chart.
* `stairs(x, y)`	Creates a stair plot, with each step centered on an (x, y) point.
* `stem(x, y)`	Creates a stem plot. It marks the points with dots and shows a vertically line between the point and the axis.
* `hist(y)`	Creates histrogram. It is used in distrubition of values areas.
* `plot3(x, y, z)`	Creates a three dimesional plot.
* `mesh(x, y, z)`	Creates a surface, mesh and contour plots. It's convient to use it with a function of two independent variables. i.e., $z = f(x, y)$

<hr>

### Cell Related Functions
* `cell()`	creates a cell array with predetermined dimensions.
* `celldisp()`	to display of the every content of a cell array.
* `cellplot()`	to display of the structure of a cell array with GUI.

<hr>

### Struct Related Functions
* `struct()`	creates a struct array with predetermined subfields.
* `rmfield()`	removes the particular field in all the struct elements.
* `getfield()`	gets the current value stored in a field.
* `setfield()`	inserts a new value into a field.

<hr>

### Input/Output Functions
* `textread()`	reads the data in a file which is contained as a formatted column model. It means that every row is another data but the fields are columns.
* `fopen()`	opens file. Returns the fid.
* `fclose()`	closes file.
* `fread()`	reads binary data from file.
* `fwrite()`	writes binary data to file.
* `fscanf()`	reads formatted data from file.
* `fprintf()`	writes formatted data to file. For details, check Lecture 9's page 18.
* `sprintf()`	exatcly the same with fprintf(), except that it writes formatted data to a character string instead of a file.
* `fgetl()`	reads line from file, discards newline character.
* `fgets()`	reads line from file, keeps newline character.
* `delete()`	deletes file.
* `exist()`	check if the file exists.
* `ferror()`	inquires about file I/O error status.
* `feof()`	tests for end-of-file.
* `fseek()`	sets file position.
* `ftell()`	checks file position.
* `frewind()`	ets the file position indicator to the beginning of the file associated with file identifier FID.
* `tempdir()`	gets temporary directory name.
* `tempname()`	gets temporary filename.